/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from "workbox-core";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== "navigate") {
      return false;
    }
    // If this is an API request, skip
    if (url.pathname.startsWith("/api")) {
      return false;
    }
    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith("/_")) {
      return false;
    }
    // If this looks like a URL for a resource, because it contains // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }
    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html"),
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: "SKIP_WAITING"})
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});

// Any other custom service worker logic can go here.
const MAX_TITLE_LENGTH = 40;

function prepareNotificationBody(results) {
  let body = "";

  results.forEach((result) => {
    if (result.data.name.length <= MAX_TITLE_LENGTH) {
      body += result.data.name;
    } else {
      body += result.data.name.slice(0, MAX_TITLE_LENGTH + 1) + "...";
    }
    body += `:    ${result.data.newChapCount} new\n`;
  });

  return body;
}

function prepareNotificationTitle(results) {
  let totalChapCount = 0;
  results.forEach((result) => {
    totalChapCount += result.data.newChapCount;
  });

  let title = `${results.length} manga`;
  if (results.length > 1) {
    title += "s have";
  } else {
    title += " has";
  }
  title += ` released ${totalChapCount} new chapter`;
  if (totalChapCount > 1) {
    title += "s";
  }
  return title;
}

self.addEventListener("push", (event) => {
  const results = event.data.json();
  const title = prepareNotificationTitle(results);
  const option = {
    body: prepareNotificationBody(results),
    requireInteraction: true,
    icon: "/favicon.ico",
    actions: [
      {
        action: "",
        title: "Go to MangaBookmark",
      },
    ],
  };
  event.waitUntil(self.registration.showNotification(title, option));
});

self.addEventListener("notificationclick", (event) => {
  const urlToOpen = new URL("/quick-access", self.location.origin).href;

  const promise = clients
    .matchAll({
      type: "window",
      includeUncontrolled: true,
    })
    .then((windowClients) => {
      let matchingWindow = null;
      for (let i = 0; i < windowClients.length; i++) {
        const wc = windowClients[i];
        // wc.url starts with urlToOpen
        if (wc.url.indexOf(urlToOpen) === 0) {
          matchingWindow = wc;
          break;
        }
      }
      if (matchingWindow) {
        return matchingWindow.focus();
      }
      return clients.openWindow(urlToOpen);
    });

  event.waitUntil(promise);
});
